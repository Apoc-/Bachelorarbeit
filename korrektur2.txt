\chapter{Einführung}\label{ch:intro}

Als Henry Ford 1913 die Produktion des Modell T, umgangssprachlich auch Tin Lizzie genannt, auf Fließbandfertigung umstellte, revolutionierte er die Automobilindustrie. Ford war nicht der erste, der diese Form der Automatisierung verwendete. Bereits 1830 kam in den Schlachthöfen von Chicago eine Maschine zum Einsatz, die an Fleischerhaken aufgehängte Tierkörper durch die Schlachterei transportierte. Bei der Produktion des Oldsmobile Curved Dash lies Ranson Eli Olds 1910 erstmals die verschiedenen Arbeitsschritte an unterschiedlichen Arbeitsstationen durchführen. Fords Revolution war die Kombination beider Ideen. Er entwickelte eine Produktionsstraße, auf welcher die Karossen auf einem Fließband von Arbeitsstation zu Arbeitsstation befördert wurden. An jeder Haltestelle wurden nur wenige Handgriffe von spezialisierten Arbeitern durchgeführt \cite{sagerso2008modelt}.

Fords Vision war es, ein Auto herzustellen, welches sich Menschen aller Gesellschaftsschichten leisten konnten. Durch die Reduktion der Produktionszeit der Tin Lizzie von 12,5 Stunden auf etwa 6 Stunden konnte Ford den Preis senken. Kostete ein Auto des Model T vor der Einführung der Produktionsstraße 825\$, erreichte der Preis in den Jahren danach einen Tiefststand von 259\$ \cite{reichlesz2010modelt}. Setzt man diesen Preis in ein Verhältnis mit dem durchschnittlichen Einkommen in den USA, das 1910 bei jährlich 438\$ lag, kann man sagen, dass Fords Traum durch die eingesetzten Techniken Realität wurde \cite{usembassyodnumbers}.

Im Zuge der weiteren Entwicklung der Robotik wurden immer mehr Aufgaben, die bisher von Menschen am Fließband durchgeführt wurden, von Automaten übernommen. In der Automobil-Industrie war General Motors der erste Hersteller, bei welchem die Produktionsstraßen im Jahr 1961 mit 66 Robotern des Typs Unimation ausgestattet wurden. Bis zur Erfindung des integrierten Schaltkreises in den 1970ern waren die Roboter ineffizient. Der Markt für industrielle Roboter explodierte jedoch in den Folgejahren. Im Jahr 1984 waren weltweit ungefähr 100.000 Roboter im Einsatz \cite{czaeis2000genprog, wallen2008robohistory}.

Die industrielle Revolution prägte die Autoindustrie: von der Erfindung auswechselbarer Teile 1910 bei Ransom Olds, über die Weiterentwicklung des Konzepts unter der Verwendung von Fließbändern bei Ford im Jahr 1913, bis hin zur abschließenden Automatisierung mit Industriellen Robotern in den frühen 1980ern. \cite{czaeis2000genprog}. . 

\section{Motivation}

\begin{quote}
	\glqq If you can compose components manually, you can also automate this process.\grqq
\end{quote}

Das hervorgehobene Zitat nennen Czarnecki und Eisenecker die "Automation Assumption". Diese allgemein gehaltene Aussage lässt die Parallelen, die die beiden Autoren zwischen der Automatisierung der Automobilindustrie und der automatischen Code Generierung !!! erkennen. Dafür müssten die einzelnen Komponenten einer Softwarefamilie derart gestaltet werden, dass diese austauschbar in eine gemeinsame Struktur integriert werden können. Des weiteren müsste klar definiert sein, welche Teile eines Programms konfigurierbar seien und welche der einzelnen Komponenten in welcher Konfiguration benötigt werden. Setzt man dieses definierte Wissen in Programmcode um, könnte ein solches Programm eine Software in einer entsprechenden Konfiguration generieren \cite{czaeis2000genprog}.

Konkret bedeutet dies, dass eine !!! vorhandene Implementation entweder in Komponenten zerlegt werden muss oder eine bereits !!! für die Zwecke der Codegenerierung vorgesehene Referenzimplementierung geschrieben wird.
Der semantische Teil einer Software, also Codeabschnitte, die in Ihrer Struktur gleich sind, sich jedoch inhaltlich unterscheiden, muss zu einem abstraktem Modell abgeleitet werden \cite{stahl2005mdsd}. Ein solches abstraktes Modell wird dann mit Daten befüllt. Schlussendlich wird ein Generator implementiert, der den Quellcode für unterschiedliche Ausprägungen eines Programms einer Software-Familie, auf Basis des konkreten Modells, generieren kann \cite{fowler2010dsls}.

Sowohl bei der Umsetzung von einzigartigen Anwendungen, als auch bei der Verwirklichung von Software mit mehreren Varianten, kann die Verwendung von bereits verfügbaren Code Generatoren oder die Entwicklung eigener Code Generatoren vorteilhaft sein. Die Entwicklungsgeschwindigkeit könnte erhöht, die Softwarequalität gesteigert und Komplexität durch Abstraktion reduziert werden \cite{stahl2007mdsd}. Allgemein wird weniger Zeit benötigt, um eine größere Vielfalt an ähnlichen Programmen zu entwickeln \cite{czaeis2000genprog}.

!!!Jede der Teilaufgaben bei der Umsetzung eines Code Generators sind jedoch bisher Tätigkeiten die meist manuell durchgeführt werden müssen.!!! Werkzeuge wie Language Workbenches generieren oder !!!interpretieren zwar Code bis zu einem gewissen Grad automatisiert!!!, haben aber in erster Linie die Aufgabe den Entwickler beim Design von externen domänenspezifischen Sprachen zu unterstützen und dienen als IDE für die Entwicklung in der Sprache \cite{fowler2010dsls}.

\section{Zielsetzung}

In dieser Arbeit soll untersucht werden, wie weitere Teile der Prozesse in der modellgetriebenen Softwareentwicklung automatisiert werden können. Potentiell könnte hier eine zusätzliche Ebene der Indirektion dieses komplexe Thema weiter vereinfachen und somit Code Generierung für mehr Entwickler zugänglich machen.

Im Speziellen wird analysiert, nach welcher Struktur ein Generator aufgebaut sein muss, um diesen von einer Referenzimplementierung des erwünschten Generats abzuleiten. Zu diesem Zweck wird eine beispielhafte Java Anwendung erarbeitet, welche als Ausgabeprodukt den Code der ursprünglichen Implementierung repliziert. Für die Transformation der Referenzimplementierung wird vorerst nur auf einen Teil des Java 8 Sprachschatzes Rücksicht genommen.

Anschließend wird ermittelt, welche Schritte unternommen werden müssen, um die bestehende Referenzimplementierung in ein abstraktes Modell abzuleiten. !!!Vor allem wie der vorhandene Quelltext bearbeitet werden muss!!! und in welcher Form das abstrakte Modell generiert werden sollte, um es als Eingabemodell für den erarbeiteten Generator zu verwenden. Hierfür wird die erste beispielhafte Anwendung weiterentwickelt, um die Generierung von Varianten der transformierten Referenzimplementierung zu ermöglichen.

Es wird in dieser Arbeit nicht auf die wirtschaftlichen Aspekte bei der Verwendung von Code Generatoren eingegangen.

\section{Aufbau der Arbeit}